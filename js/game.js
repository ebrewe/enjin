// Generated by CoffeeScript 1.4.0
(function() {
  var Entity, Game, HUD, HUDElement, InputHandler, LevelMap, Sprite, Tile, World,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Game = (function() {

    function Game(container, tileSize, _arg) {
      var paused, viewHeight, viewWidth, _ref;
      this.container = container;
      this.tileSize = tileSize;
      _ref = _arg != null ? _arg : {}, viewHeight = _ref.viewHeight, viewWidth = _ref.viewWidth;
      this.tick = __bind(this.tick, this);

      this.viewHeight = viewHeight != null ? viewHeight : 400;
      this.viewWidth = viewWidth != null ? viewWidth : 600;
      this.tileHeight = this.tileSize;
      this.tileWidth = this.tileSize * 2;
      this.levels = [];
      this.currentLevel = 0;
      paused = false;
    }

    Game.prototype.start = function() {
      this.setup();
      this.then = Date.now();
      return setInterval(this.tick, 1000 / 30);
    };

    Game.prototype.setup = function() {
      this.world = new World(this.container, this.tileWidth, this.tileHeight, this.viewWidth, this.viewHeight);
      return this.inputHandler = new InputHandler(this.world);
    };

    Game.prototype.update = function(options) {
      var updates;
      updates = options != null ? options : false;
      this.inputHandler.update();
      return this.world.update(updates);
    };

    Game.prototype.tick = function() {
      var updates;
      this.now = Date.now();
      this.twixt = this.now - this.then;
      this.then = this.now;
      updates = {
        hud: {
          frameRate: this.twixt
        }
      };
      this.update(updates);
      return this.world.draw();
    };

    Game.prototype.initiate = function(levels) {
      var _this = this;
      this.levels = levels;
      if (this.levels[this.currentLevel]) {
        this.world.doScene(this.levels[this.currentLevel]);
      }
      $(this.world.el).click(function() {
        return _this.inputHandler.clicked = true;
      });
      $(this.world.el).on('mousedown', function() {
        _this.inputHandler.mouseDown = true;
        return _this.inputHandler.startClick(_this.then);
      });
      return $(this.world.el).on('mouseup', function() {
        return _this.inputHandler.endDrag();
      });
    };

    return Game;

  })();

  /*
  ******************************
  THE GREAT WORLD CLASS
  ******************************
  */


  World = (function() {

    World.prototype.scene = [];

    World.prototype.sprites = [];

    World.prototype.background = false;

    World.prototype.defaultScroll = {
      x: 0,
      y: 0
    };

    function World(container, tileWidth, tileHeight, w, h, _arg) {
      var scrollX, scrollY, _ref;
      this.container = container;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.w = w;
      this.h = h;
      _ref = _arg != null ? _arg : {}, scrollX = _ref.scrollX, scrollY = _ref.scrollY;
      this.scrollX = scrollX != null ? scrollX : 0;
      this.scrollY = scrollY != null ? scrollY : 0;
      this.defaultScrollX = scrollX != null ? scrollX : 0;
      this.defaultScrollY = scrollY != null ? scrollY : 0;
      this.scrollTarget = {
        x: this.defaultScrollX,
        y: this.defaultScrollY
      };
      this.quickScroll = false;
      this.objects = [];
      this.entities = [];
      this.square = false;
      this.createWorld();
    }

    World.prototype.createWorld = function() {
      this.el = this.container;
      return $(this.el).css({
        'display': 'block',
        'position': 'relative',
        'width': '90%',
        'height': this.h + 'px'
      }).attr('data-dragging', 'false');
    };

    World.prototype.createHUD = function(elements) {
      var options;
      options = [];
      return this.hud = new HUD(this.container, {
        elements: elements,
        options: options
      });
    };

    World.prototype.update = function(updates) {
      var ent, hupdates, tile, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      hupdates = (_ref = updates.hud) != null ? _ref : {};
      if (hupdates.frameRate) {
        this.hud.elements.frames.update(hupdates.frameRate);
      }
      if (this.tiles) {
        _ref1 = this.tiles;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          tile = _ref1[_i];
          tile.update();
        }
      }
      _ref2 = this.entities;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        ent = _ref2[_j];
        ent.update();
      }
      if (this.quickScroll) {
        return this.scrollQuick();
      }
    };

    World.prototype.draw = function() {
      var ent, tile, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (this.tiles) {
        _ref = this.tiles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tile = _ref[_i];
          tile.draw();
        }
      }
      _ref1 = this.entities;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ent = _ref1[_j];
        _results.push(ent.draw());
      }
      return _results;
    };

    World.prototype.doScene = function(scene) {
      var row, tile, _base, _i, _j, _len, _len1, _ref, _ref1, _ref2,
        _this = this;
      this.scene = scene != null ? scene : {};
      this.square = this.scene.square;
      if ((_ref = (_base = this.scene).hud) == null) {
        _base.hud = [];
      }
      this.createHUD(this.scene.hud);
      $(this.hud.el).on('click', '#center', function() {
        _this.scrollTarget = {
          x: _this.defaultScrollX,
          y: _this.defaultScrollY
        };
        return _this.quickScroll = true;
      });
      if (this.scene.scroll) {
        this.scrollX = this.scene.scroll.x;
        this.scrollY = this.scene.scroll.y;
        this.defaultScrollX = this.scene.scroll.x;
        this.defaultScrollY = this.scene.scroll.y;
      }
      if (this.scene.map) {
        this.tiles = [];
        this.map = new LevelMap(this.scene.map, this.tileWidth, this.tileHeight, this.square);
        this.map.image = (_ref1 = this.scene.mapImage) != null ? _ref1 : false;
        if (this.map.image === false) {
          this.map.image = this.square ? 'images/square_iso_small.png' : 'images/hextile_iso_v.png';
        }
        this.cMap = this.scene.map;
        _ref2 = this.cMap;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          row = _ref2[_i];
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            tile = row[_j];
            if (row[tile] === 'x') {
              row[tile] = 1;
            } else {
              row[tile] = 0;
            }
          }
        }
        this.createPFGrid(this.cMap);
        this.placeTiles();
      }
      if (this.scene.sprites) {
        return this.addSprites(this.scene.sprites);
      }
    };

    World.prototype.createPFGrid = function(map) {
      this.grid = new PF.Grid(map[0].length, map.length, map);
      return this.finder = new PF.BreadthFirstFinder({
        allowDiagonal: true
      });
    };

    World.prototype.placeTiles = function() {
      var cIndex, column, m, rIndex, row, tile, world, _ref, _results;
      world = this;
      m = (_ref = this.map.tiles) != null ? _ref : false;
      if (m) {
        _results = [];
        for (rIndex in m) {
          row = m[rIndex];
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (cIndex in row) {
              column = row[cIndex];
              tile = this.map.tiles[rIndex][cIndex];
              tile.tile = new Tile(world, tile.x, tile.y, this.tileWidth, this.tileWidth, this.map.image, {
                row: rIndex,
                col: cIndex,
                type: tile.type,
                offset: {
                  x: 0,
                  y: 22
                },
                render: true
              });
              _results1.push(this.tiles.push(tile.tile));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    };

    World.prototype.makePath = function(start, end) {
      var gridClone;
      gridClone = this.clone(this.grid);
      return this.finder.findPath(start.x, start.y, end.x, end.y, gridClone);
    };

    World.prototype.clone = function(obj) {
      var flags, key, newInstance;
      if (!(obj != null) || typeof obj !== 'object') {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = this.clone(obj[key]);
      }
      return newInstance;
    };

    World.prototype.addSprites = function(sprites) {
      var spriteGroup, _results;
      _results = [];
      for (spriteGroup in sprites) {
        sprites = sprites[spriteGroup];
        switch (spriteGroup) {
          case 'entities':
            _results.push(this.addEntities(sprites));
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    World.prototype.addEntities = function(entities) {
      var animations, coords, ent, entity, h, image, name, offset, speed, w, world, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      world = this;
      _results = [];
      for (_i = 0, _len = entities.length; _i < _len; _i++) {
        ent = entities[_i];
        name = (_ref = ent.name) != null ? _ref : false;
        coords = (_ref1 = ent.coords) != null ? _ref1 : {
          x: 0,
          y: 0
        };
        coords = this.tileToCoords(coords);
        w = (_ref2 = ent.width) != null ? _ref2 : this.tileWidth;
        h = (_ref3 = ent.height) != null ? _ref3 : this.tileHeight;
        image = (_ref4 = ent.image) != null ? _ref4 : false;
        animations = (_ref5 = ent.animations) != null ? _ref5 : false;
        offset = (_ref6 = ent.offset) != null ? _ref6 : false;
        speed = (_ref7 = ent.speed) != null ? _ref7 : 0;
        entity = new Entity(world, coords.x, coords.y, w, h, image, {
          name: name,
          animations: animations,
          offset: offset,
          speed: speed
        });
        _results.push(this.entities.push(entity));
      }
      return _results;
    };

    World.prototype.tileToCoords = function(coords) {
      var tile, _i, _len, _ref;
      if (!coords.x) {
        coords = {
          x: coords[0],
          y: coords[1]
        };
      }
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (tile.row === ("" + coords.x) && tile.col === ("" + coords.y)) {
          return {
            x: tile.x,
            y: tile.y
          };
        }
      }
      console.log('no matching tile');
      return {
        x: 0,
        y: 0
      };
    };

    World.prototype.coordsToTile = function(coords) {
      var tile, _i, _len, _ref;
      if (!coords.x) {
        coords = {
          x: coords[0],
          y: coords[1]
        };
      }
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (tile.x >= coords.x - 5 && tile.x <= coords.x + 5 && tile.y >= coords.y - 5 && tile.y <= coords.y + 5) {
          return {
            x: tile.row,
            y: tile.col
          };
        }
      }
      console.log('no matching tile');
      return false;
    };

    World.prototype.scrollQuick = function() {
      if (Math.abs(this.scrollX - this.scrollTarget.x) <= this.tileWidth) {
        this.scrollTarget.x = this.scrollX;
      } else {
        this.scrollX = this.scrollX > this.scrollTarget.x ? this.scrollX - this.tileWidth : this.scrollX + this.tileWidth;
      }
      if (Math.abs(this.scrollY - this.scrollTarget.y) <= this.tileWidth) {
        this.scrollTarget.y = this.scrollY;
      } else {
        this.scrollY = this.scrollY > this.scrollTarget.y ? this.scrollY - this.tileWidth : this.scrollY + this.tileWidth;
      }
      if (this.scrollX === this.scrollTarget.x && this.scrollY === this.scrollTarget.y) {
        return this.quickScroll = false;
      }
    };

    return World;

  })();

  LevelMap = (function() {

    function LevelMap(map, tileWidth, tileHeight, square) {
      this.map = map;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.square = square;
      this.columns = this.map.length;
      this.rows = this.map[0].length;
      this.tiles = {};
      this.build();
    }

    LevelMap.prototype.build = function() {
      var cIndex, column, coords, rIndex, row, tx, ty, _ref, _results;
      _ref = this.map;
      _results = [];
      for (rIndex in _ref) {
        row = _ref[rIndex];
        this.tiles[rIndex] = {};
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (cIndex in row) {
            column = row[cIndex];
            tx = cIndex * this.tileWidth;
            ty = rIndex * this.tileHeight;
            coords = this.toIso(tx, ty, rIndex, cIndex);
            _results1.push(this.tiles[rIndex][cIndex] = {
              x: coords.x,
              y: coords.y,
              type: column
            });
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    LevelMap.prototype.toIso = function(x, y, r, c) {
      var dx, dy;
      if (this.square) {
        dx = x / 2 + ((this.rows - r) * (this.tileWidth / 2));
        dy = y / 2 + (c * (this.tileHeight / 2) - .5);
      } else {
        dx = x * 2 / 3;
        dy = y + ((c % 2) * this.tileHeight / 2);
      }
      return {
        x: dx,
        y: dy
      };
    };

    return LevelMap;

  })();

  /*
  ******************************
  THE IMPACTFUL INPUT-HANDLER
  ******************************
  */


  InputHandler = (function() {

    InputHandler.prototype.keysPressed = [];

    InputHandler.prototype.clicked = false;

    InputHandler.prototype.mousePos = {};

    InputHandler.prototype.mouseDown = false;

    InputHandler.prototype.dragging = false;

    InputHandler.prototype.dragStart = {};

    InputHandler.prototype.hovering = false;

    function InputHandler(world) {
      this.world = world;
      this.update = __bind(this.update, this);

      this.bindMouse = __bind(this.bindMouse, this);

      this.bindMouse();
    }

    InputHandler.prototype.bindMouse = function() {
      var that;
      that = this;
      return document.addEventListener('mousemove', function(evt) {
        return that.mousePos = that.getMousePos(evt);
      });
    };

    InputHandler.prototype.getMousePos = function(evt) {
      var rect, wScrollX, wScrollY;
      rect = this.world.el;
      wScrollX = $('body').scrollLeft();
      wScrollY = $('body').scrollTop();
      return {
        x: evt.clientX - $(rect).offset().left,
        y: evt.clientY - $(rect).offset().top + wScrollY
      };
    };

    InputHandler.prototype.update = function() {
      var dX, dY, tile, _i, _len, _ref;
      if (this.world.tiles) {
        this.hovering = false;
        _ref = this.world.tiles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tile = _ref[_i];
          tile.clearFlags(['hover']);
          if (this.mousePos.x >= tile.rx && this.mousePos.x <= tile.rx + tile.w && this.mousePos.y >= tile.ry && this.mousePos.y <= tile.ry + tile.h) {
            this.hovering = tile;
          }
        }
      }
      if (this.hovering) {
        this.hovering.setFlags(['hover']);
        if (this.clicked) {
          console.log(this.hovering.row, this.hovering.col);
        }
      }
      if (this.mouseDown) {
        this.checkDrag();
      }
      $(this.world.el).attr('data-dragging', false);
      if (this.dragging) {
        $(this.world.el).attr('data-dragging', true);
        dX = this.mousePos.x - this.dragStart.x;
        dY = this.mousePos.y - this.dragStart.y;
        if (Math.abs(dX) > 5) {
          this.world.scrollX = dX;
        }
        if (Math.abs(dY) > 5) {
          this.world.scrollY = dY;
        }
      }
      return this.clicked = false;
    };

    InputHandler.prototype.checkDrag = function() {
      var holding, now;
      now = new Date();
      holding = now - this.clickStart;
      if (holding >= 200) {
        this.dragging = true;
        return true;
      }
      return false;
    };

    InputHandler.prototype.startClick = function(time) {
      this.clickStart = time;
      return this.dragStart = {
        x: this.mousePos.x - this.world.scrollX,
        y: this.mousePos.y - this.world.scrollY
      };
    };

    InputHandler.prototype.endDrag = function() {
      this.mouseDown = false;
      return this.dragging = false;
    };

    return InputHandler;

  })();

  HUD = (function() {

    HUD.prototype.elements = {};

    function HUD(container, _arg) {
      var element, elements, options, _i, _len, _ref;
      _ref = _arg != null ? _arg : {}, elements = _ref.elements, options = _ref.options;
      this.parent = container;
      HUD = document.createElement('div');
      HUD.setAttribute('id', 'game_hud');
      this.parent.appendChild(HUD);
      this.el = HUD;
      $(this.el).css({
        'display': 'block',
        'position': 'absolute',
        'top': 0,
        'left': 0,
        'width': $(this.parent).width(),
        'height': $(this.parent).height()
      });
      if (elements) {
        for (_i = 0, _len = elements.length; _i < _len; _i++) {
          element = elements[_i];
          this.createElement(element);
        }
      }
      return this;
    }

    HUD.prototype.createElement = function(element) {
      var el;
      el = new HUDElement(element, this.el);
      return this.elements[element] = el;
    };

    return HUD;

  })();

  HUDElement = (function() {

    function HUDElement(element, hud) {
      var el;
      this.element = element;
      el = document.createElement('div');
      el.setAttribute('id', this.element);
      hud.appendChild(el);
      this.el = el;
      this.customize();
      $(this.el).css({
        "-moz-user-select": "none",
        "-khtml-user-select": "none",
        "-webkit-user-select": "none",
        "-o-user-select": "none"
      });
      $(this.el).on('mousenter', function() {
        return $(this.el).addClass('hover');
      });
      $(this.el).on('mouseleave', function() {
        return $(this.el).removeClass('hover');
      });
    }

    HUDElement.prototype.customize = function() {
      switch (this.element) {
        case 'frames':
          return console.log('frames built!');
        case 'center':
          return $(this.el).css({
            'display': 'block',
            'width': '50px',
            'height': '50px',
            'background': 'url(images/center_button.png) no-repeat 0 0'
          });
      }
    };

    HUDElement.prototype.update = function(updateVal) {
      return this.el.innerHTML = updateVal;
    };

    return HUDElement;

  })();

  /*
  ******************************
  THE ALL-SINGING SPRITE CLASSES
  ******************************
  */


  Sprite = (function() {

    function Sprite(world, x, y, w, h, image, options) {
      var sprite, _ref, _ref1, _ref2, _ref3, _ref4;
      this.world = world;
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.image = image;
      this.offset = (_ref = options.offset) != null ? _ref : {
        x: 0,
        y: 0
      };
      this.zIndex = (_ref1 = options.zIndex) != null ? _ref1 : 1;
      this.z = this.zIndex + (this.y * this.world.tileHeight);
      this.name = (_ref2 = options.name) != null ? _ref2 : 'sprite';
      this.current_frame = 0;
      this.current_animation = 'standard';
      this.fps = (_ref3 = options.fps) != null ? _ref3 : 1000 / 24;
      this.render = (_ref4 = options.render) != null ? _ref4 : true;
      this.animations = {
        'standard': ['a0']
      };
      if (this.render) {
        sprite = document.createElement('div');
        if (this.name !== 'sprite') {
          sprite.setAttribute('id', this.name);
        }
        sprite.className += 'sprite ';
        if (this.name !== 'sprite') {
          sprite.className += this.name;
        }
        this.world.container.appendChild(sprite);
        this.el = sprite;
        $(this.el).css({
          'display': 'block',
          'position': 'absolute',
          'top': this.y + 'px',
          'left': this.x + 'px',
          'width': this.w + 'px',
          'height': this.h + 'px',
          'z-index': Math.ceil(this.z),
          'background-image': 'url(' + this.image + ')',
          'background-repeat': 'no-repeat'
        });
      }
    }

    Sprite.prototype.update = function(modifier) {
      this.z = Math.ceil(this.zIndex + (this.y * this.world.tileHeight));
      this.ry = this.y + this.world.scrollY;
      return this.rx = this.x + this.world.scrollX;
    };

    Sprite.prototype.getFrame = function(animation) {
      var a, fr, now;
      if (!this.frameTime) {
        this.frameTime = new Date();
      }
      now = new Date();
      fr = this.current_frame;
      a = this.animations[animation];
      if (now - this.frameTime < this.fps) {
        return this.processFrame(a[fr]);
      }
      if (!a) {
        return {
          x: 0,
          y: 0
        };
      }
      if (!a[fr] || !a[fr + 1] || a.length <= 1) {
        this.current_frame = 0;
        return this.processFrame(a[this.current_frame]);
      }
      this.current_frame += 1;
      return this.processFrame(a[this.current_frame]);
    };

    Sprite.prototype.processFrame = function(aframe) {
      var alpha, c, ex, r, wy;
      alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
      c = aframe.substring(0, 1);
      r = aframe.substring(1, aframe.length);
      ex = parseInt(r) * this.w;
      wy = this.h * alpha.indexOf(c);
      return {
        x: ex,
        y: wy
      };
    };

    Sprite.prototype.draw = function() {
      var bgi;
      if (this.el) {
        bgi = this.getFrame(this.current_animation);
        return $(this.el).css({
          'z-index': this.z,
          'top': (this.ry - this.h + this.offset.y) + 'px',
          'left': (this.rx + this.offset.x) + 'px',
          'background-position': '-' + bgi.x + 'px ' + '-' + bgi.y + 'px'
        });
      }
    };

    return Sprite;

  })();

  Tile = (function(_super) {

    __extends(Tile, _super);

    function Tile(world, x, y, w, h, image, options) {
      var _ref, _ref1, _ref2;
      if (!options.name) {
        options.name = 'tile';
      }
      this.row = (_ref = options.row) != null ? _ref : "0";
      this.col = (_ref1 = options.col) != null ? _ref1 : "0";
      Tile.__super__.constructor.call(this, world, x, y, w, h, image, options);
      this.flags = [];
      this.animations = (_ref2 = options.animations) != null ? _ref2 : {
        'standard': ['a0'],
        'hover': ['a1'],
        'selected': ['a2']
      };
      this.type = options.type || options.type === 0 ? this.getType(options.type) : {
        height: 0
      };
      this.height = this.type.height;
      if (this.el) {
        $(this.el).css({
          'background': 'url(' + this.image + ') no-repeat 0 0'
        });
      }
    }

    Tile.prototype.update = function(modifier) {
      Tile.__super__.update.call(this, modifier);
      this.current_animation = 'standard';
      if (this.flags['hover']) {
        this.current_animation = 'hover';
      }
      if (this.flags['path']) {
        this.current_animation = 'selected';
      }
      return this.ry += this.height * (-this.world.tileHeight);
    };

    Tile.prototype.draw = function() {
      return Tile.__super__.draw.apply(this, arguments);
    };

    Tile.prototype.setFlags = function(flags) {
      var flag, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = flags.length; _i < _len; _i++) {
        flag = flags[_i];
        this.flags[flag] = true;
        if (this.el) {
          _results.push($(this.el).addClass(flag));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Tile.prototype.clearFlags = function(flags) {
      var flag, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = flags.length; _i < _len; _i++) {
        flag = flags[_i];
        this.flags[flag] = false;
        if (this.el) {
          _results.push($(this.el).removeClass(flag));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Tile.prototype.getType = function(tile) {
      if (isFinite(tile)) {
        this.setFlags(['walkable']);
        return {
          height: tile
        };
      } else {
        return {
          height: 0
        };
      }
    };

    return Tile;

  })(Sprite);

  /*
  ******************************
  THE ASTONISHING ENTITIES CLASSES
  ******************************
  */


  Entity = (function(_super) {

    __extends(Entity, _super);

    Entity.prototype.vx = 0;

    Entity.prototype.vy = 0;

    function Entity(world, x, y, w, h, image, options) {
      var _ref;
      if ((_ref = options.name) == null) {
        options.name = 'entity';
      }
      this.speed = options.speed && options.speed > 0 ? options.speed : 3;
      this.speedX = this.speed;
      this.speedY = this.speed;
      Entity.__super__.constructor.call(this, world, x, y, w, h, image, options);
    }

    Entity.prototype.update = function(modifier) {
      this.vx = 0;
      this.vy = 0;
      if (this.target && this.targetCoords) {
        if (this.reasonablyNear(this.targetCoords)) {
          this.path.shift();
          if (this.path.length > 1) {
            this.setPath(this.path[this.path.length - 1]);
            this.moveTo(this.targetCoords);
          } else {
            this.path = false;
            this.stopMoving();
          }
        } else {
          this.moveTo(this.targetCoords);
        }
      }
      this.x += this.vx;
      this.y += this.vy;
      Entity.__super__.update.call(this, modifier);
      if (this.world.debug) {
        return $(this.el).css({
          'border': '1px solid black'
        });
      }
    };

    Entity.prototype.draw = function() {
      return Entity.__super__.draw.apply(this, arguments);
    };

    Entity.prototype.setPath = function(coords) {
      var end, gridClone, start, _ref;
      start = this.world.coordsToTile([this.x, this.y]);
      end = coords.x ? coords : {
        x: coords[0],
        y: coords[1]
      };
      gridClone = this.world.clone(this.world.grid);
      this.path = this.world.finder.findPath(start.x, start.y, end.x, end.y, gridClone);
      this.target = (_ref = this.path[1]) != null ? _ref : false;
      return this.targetCoords = this.target ? this.world.tileToCoords([this.target[0], this.target[1]]) : false;
    };

    Entity.prototype.moveTo = function(coords) {
      var dx, dy, target;
      target = coords.x ? coords : {
        x: coords[0],
        y: coords[1]
      };
      dx = this.x - target.x;
      dy = this.y - target.y;
      this.vx = dx > 0 ? -this.speedX : this.speedX;
      this.vy = dy > 0 ? -this.speedY : this.speedY;
      if (Math.abs(dx) < 2) {
        this.vx = 0;
      }
      if (Math.abs(dy) < 2) {
        return this.vy = 0;
      }
    };

    Entity.prototype.stopMoving = function() {
      this.vx = 0;
      this.vy = 0;
      this.target = false;
      return this.targetCoords = false;
    };

    Entity.prototype.reasonablyNear = function(target) {
      var coords;
      coords = target.x ? target : {
        x: target[0],
        y: target[1]
      };
      if (this.x >= coords.x - 2 && this.x <= coords.x + 2 && this.y >= coords.y - 2 && this.y <= coords.y + 2) {
        return true;
      }
      return false;
    };

    return Entity;

  })(Sprite);

  /*
  ******************************
  THE MIND-BOGGLING KICK-OFF CODE
  ******************************
  */


  window.onload = function() {
    var bob, game, gameContainer, levelOne, levels, lvOneMap, lvOneSprites;
    console.log('starting');
    lvOneMap = [['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'x'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x']];
    lvOneSprites = {
      entities: [
        {
          name: 'bob',
          coords: {
            x: 10,
            y: 10
          },
          width: 44,
          height: 66,
          image: 'images/eric.png',
          animations: {
            standard: ['a0']
          },
          offset: {
            x: -15,
            y: 10
          }
        }
      ]
    };
    levelOne = {
      map: lvOneMap,
      square: true,
      sprites: lvOneSprites,
      scroll: {
        x: 50,
        y: 100
      },
      hud: ['frames', 'center']
    };
    levels = [levelOne];
    gameContainer = document.getElementById('game');
    game = new Game(gameContainer, 11);
    game.start();
    game.world.debug = true;
    game.initiate(levels);
    bob = game.world.entities[0];
    return bob.setPath([18, 18]);
  };

}).call(this);
